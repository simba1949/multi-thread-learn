# Java 多线程之线程间通信

## wait() 方法

> wait() 方法的作用是使当前执行代码的线程进行等待，wait() 方法是 Object 类的方法，该方法用来将当前线程置入 “预执行队列” 中，并且在 wait() 所在的代码行处停止执行，直到接到通知或被中断而止。在调用 wait() 之前，线程必须获得该对象的对象级别锁，即只能在同步方法或者同步代码块中调用 wait() 方法。在执行 wait() 方法后，当前线程释放锁。在从 wait() 返回前，线程与其他线程竞争重新获取锁。如果调用  wait() 是没有持有适当的锁，则抛出 IllegalMonitorStateException ，它是 RuntimeException 的一个子类，因此，不需要 try-catch 语句进行捕捉异常。

## notify() 方法

> notify() 方法要在同步发放或者同步块中调用，即在调用前，线程也必须获取该对象的对象级别锁。如果调用 notity() 时没有持有适当的锁，也会抛出 IllegalMonitorStateException 。该方法用来通知那些可能等待对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选其中一个 wait 状态的线程，对其发出通知 notify ，并使它等待获取该对象的对象锁。需要说明的是，在执行 notity() 方法后，当前线程不会马上释放该对象锁，wait 状态的线程也不能马上获取该对象锁，要等到执行 notify 方法的线程将程序执行完，也就是退出 synchronized 代码块后，当前线程才会释放锁，而 wait 状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的 wait 线程运行完毕以后，他会释放该对象锁，此时如果该对象没有再次使用 notify 语句，则即便该对象已经空闲，其他 wait 状态等待的线程由于没有得到该对象的通知，还会继续阻塞 wait 状态，直到这个对象发出一个 notify 或者 notifyAll。

用一句话总结 wait 和 notify ：wait 使线程停止运行，notify 使停止的线程继续运行。

## 通过管道进行线程间通信：字节流

在 Java 语言中提供了各种各样的输入/输出流 stream，使我们能够很方便地对数据进行操作，其中管道流（pipeStream）是一种特殊的流，用于在不同线程间直接传输数据。一个线程发送数据到输出管道，另一个线程从输入管道中读数据。通过使用管道，实现不同线程间通信，而无须借助于临时文件之类的东西。

在 Java 的 JDK 中提供了 4 个类来使线程间可以进行通信：

1. PipedInputStream & PipedOutputStream
2. PipedReader & PipedWriter

## 方法 join 的使用

在很多情况下啊，主线程创建子线程，如果子线程中要进行大量的好事运算，主线程往往将早于子线程结束之前结束。这是，如果主线程想等待子线程执行完成之后在结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到 join() 方法了。方法 join() 的作用是等待线程对象销毁。

## 类 ThreadLocal 的使用

变量值得共享可以使用 public static 变量的形式，所有的线程都是用都使用同一个 public static 变量。如果想实现每一个线程都有自己的变量该如何解决？ JDK 中提供类 ThreadLocal 正是为了解决这一的问题。

类 ThreadLocal 主要解决的就是每个线程绑定自己的值，可以将 ThreadLocal 类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。

## 类 InheritableThreadLocal 的使用

使用类 InheritableThreadLocal 可以在子线程中取得父线程继承下来的值。

值得注意的是：如果子线程在取值的同时，主线程将 InheritableThreadLocal 中的值进行更改，那么子线程取到的值还是旧值。