# Java 多线程之 Synchronized & Volatile

“非线程安全” 其实会在多线程对同一对象中的实例变量进行并发访问时发生，产生的后果就是 “脏读” ，也就是获取到的数据其实是被更改过的数据。而 “线程安全” 就是以获取的实例变量的值是经过同步处理的，不会出现脏读的现象。

## Synchronized

同步：synchronized

异步 ：asynchronized

关键字 Synchronized 可以保证在同一时刻，只有一个线程可以执行某一个方法或某个代码块。它包含两个特征:互斥性和可见性。同步 Synchronized 不仅可以解决个线程看到对象处于不一致的状态，还可以保证进人同步方法或者同步代码块的每个线程，都看到由同一个锁保护之前所有的修改效果。

### synchronized 锁重入

关键字 synchronized 拥有锁重入的功能，也就是在使用 synchronized 时，当一个线程得到一个对象锁后，再次请求此对象锁时时可以再次得到该对象的锁的。这也证明在一个 synchronized 方法/块的内部调用本类的其他 synchronized 方法/块是，是永远可以得到锁的。

可重入锁也支持父子类继承的环境中。

出现异常锁自动释放

### 同步方法 & 同步代码块

- synchronized 同步方法
- synchronized 同步代码块：当两个并发线程访问同一个对象 Object 中的 synchronized(this) 同步代码块时，一段时间内只能有一个线程被执行，另一个线程必须等待当前线程执行完成这个代码块以后才能执行该代码块。

> 同步方法弊端：运行时间长
>
> 同步代码块弊端：不在 synchronized 块中就是异步执行，在 synchronized 块中就是同步执行。

将任意对象作为对象监视器，这个 “任意对象” 大多数是实例变量及方法参数，使用格式为：

```java
Object user = new User();
synchronized(user){
    
}
```

锁非 this 对象具有一定的有点：如果在一个类中有很多个 synchronized 方法，这是虽然能实现同步，但是会受到阻塞，所以影响了运行效率；但是如果使用同步代码块锁非 this 对象，则 synchronized(非this) 代码块中的程序与同步方法时异步的，不与其他锁 this 同步方法争抢 this 锁，则可以大大提高运行效率。

### 静态同步 synchronized 方法与 synchronized(class) 代码块

关键字 synchronized 还可以应用在 static 静态方法上，如果这样写，那是对当前的 Java 文件对应的 Class 类进行持锁。

## Volatile

> Volatile 的主要作用是使变量在多个线程间可见。是强制从公共堆栈中获取变量的值，而不是从线程私有数据栈中获取变量的值。
>
> 使用 Volatile 关键字增加了实例变量在多个线程之间的可见性。但是 Volatile 关键字最致命的确定是不支持原子性。
>
> Volatile 虽然增加了实例变量在多个线程的可见性，但它却不具备同步性，那么也就不具备原子性。关键字volatile提示线程每次从共享内存中读取变量，而不是从私有内存中读取，这样就保证了同步数据的可见性。但在这里需要注意的是：如果修改实例变量中的数据，比如 i++，也就是i=i+1，则这样
> 结果的操作其实并不是一个原子操作，也就是非线程安全的。表达式i++的操作步骤分解如下:
> 1 ) 从内存中取出i的值;
> 2) 计算i的值;
> 3) 将i的值写到内存中。
> 假如在第2步计算值的时候，另外一个线程也修改i的值，那么这个时候就会出现脏数据。解决的办法其实就是使用synchronized关键字。所以说 Volatile 本身并不处理数据的原子性，而是强制对数据的读写及时影响到主内存的。

## Synchronized & Volatile 对比

1. 关键字 Volatile 是线程同步的轻量级实现，所以 Volatile 性能肯定比 Synchronized 要好，并且 Volatile 只能修饰变量，而 Synchronized 可以修饰方法、代码块。随着 JDK 新版本的发布，Synchronized 关键字在执行效率上得到了很大的提升，在开发中使用 Synchronized 关键字的比率还是比较大的。
2. 多线程访问 Volatile 不会发生阻塞，而 Synchronized 会出现阻塞。
3. Volatile 能保证数据的可见性，而不能保证原子性；而 Synchronized 可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步。
4. Volatile 解决的是变量在多个线程之间的可见性；而 Synchronized 关键字解决的是多个线程之间访问资源的同步性。

线程安全包含原子性和可见性两方面，Java 的同步机制都是围绕着两方面来确保线程安全的。







