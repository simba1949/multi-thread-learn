# Java 多线程基础

## 基础概念

### 进程与线程

为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块（Process Control Block，PCB）。系统利用 PCB 描述进程的基本情况和运行态，进而控制和管理进程。相应地，由程序段、相关数据段和 PCB 三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的 PCB；而撤销进程，实质上是撤销进程的 PCB。值得注意的是，进程映像是静态的，进程是动态的。

### 多线程不安全

非线程安全主要指多个线程对同一个对象中的同一个实例变量进行操作时会出现值被更改、值不同步的情况，进而影响程序的执行流程。

### 常见方法

- currentThread()：执行当前代码的线程信息；
- isAlive()：判断当前的线程是否处于活动状态；
- sleep()：在指定的毫秒数内让当前的正在执行的线程，休眠（暂停执行），不释放当前获取的锁（wait 方法释放了锁），不放弃 CPU 的使用权（yeid 方法放弃 CPU 使用权重新进去就绪队列抢夺 CPU）
- getId()：获取线程的唯一标识
- interrupt()：这个方法不会终止一个正在运行的线程，需要加入一个判断才能完成线程的终止。
- Thread.yield()：（静态方法）放弃当前的 CPU 资源，将它让给其他的任务去占用 CPU 执行时间。但放弃的时间不确定，有可能刚刚放弃，马上有获取 CPU 时间片。
- setPriority()：设置线程优先级，优先级越高获取 CPU 执行权限的概率越大（1~10数值越大概率越大）

### 停止线程

在 Java 中有以下 3 种可以终止正在运行的线程

1. 当 run 方法执行完成后线程终止；
2. 使用 stop 方法强制终止线程（暴力停止），但是不安全；
3. 使用 interrupt 方法中断线程。
4. （*）异常法停止线程；
5. （*）使用 return 停止线程；

### 判断线程是否是停止状态

- Thread.interrupted()：（静态方法)，测试当前线程是否已经是中断状态，执行后具有将状态标志清除为 false 的功能
- isInterrupted()：测试线程 Thread 对象是否已经是中断状态，但是不清除状态标志。

### 暂停线程

- suspend
- resume

缺点：

1）独占：如果使用不当，极易造成公共的同步对象的独占，使得其他线程无法访问公共同步对象

2）不同步：容易出现因为线程的暂停而导致数据不同步的情况

### 线程的优先级

setPriority()：设置线程优先级，优先级越高获取 CPU 执行权限的概率越大（1~10数值越大概率越大）

在 Java 中，线程的优先级具有继承性，比如 A 线程启动 B 线程，则 B 线程的优先级与 A 线程是一样的。

### 守护线程

在 Java 线程中有两种线程，一种是用户线程，一种是守护线程。

守护线程是一种特殊的线程，它的特性有“陪伴”的含义，当进程中不存在非守护线程了，则守护线程自动销毁。

典型的守护线程就是垃圾回收线程

## 实现多线程的方式

1. 继承 Thread 类
2. 实现 Runnable 接口

继承 Thread 类

```java
package top.simba1949;

/**
 * 1. 继承 Thread 类
 * 2. 重写 run 方法
 *
 * @author SIMBA1949
 * @date 2019/8/4 11:23
 */
public class ExtendThread extends Thread {

    @Override
    public void run() {
        
    }
}
```

实现 Runnable 接口

```java
package top.simba1949;

/**
 * 1. 实现 Runnable 接口
 * 2. 重写 run 方法
 * @author SIMBA1949
 * @date 2019/8/4 14:27
 */
public class ImplRunnable implements Runnable {
    @Override
    public void run() {
        
    }
}
```





